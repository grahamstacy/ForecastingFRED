library(tidyverse)
library(tsibble)
library(lubridate)
library(timetk)
library(fredr)
library(stats)
library(forecast)
library(dplyr)
library(stats)

fredr::fredr_set_key("0962c1d1b6316b7c4b6c68ced8211ac9")

fred_fcast <- function(fred_api_key, 
                       fred_series_id, 
                       freq = NULL, 
                       h=1, nsim=1000, 
                       conf=0.80, 
                       units="lin", 
                       aggregation_method = "avg",
                       window = 0) {
  
  compute <- function(fred_api_key, 
                      fred_series_id, 
                      freq, 
                      h, 
                      nsim, 
                      conf, 
                      units, 
                      aggregation_method,
                      window) {
    
    fredr::fredr_set_key(fred_api_key)
    
    tibble0 <- fredr::fredr(series_id = fred_series_id, frequency = freq, units = units, aggregation_method = aggregation_method) %>% 
      select(date, value) %>%
      na.omit()
    
    calculate_dates <- function(tibble, window) {
      
      dates0 <- tibble$date
      n0 <- dates0 %>% length()
      months0.diff <- dates0 %>% month() %>% diff()
      months0.diff.adjusted <- months0.diff[months0.diff > 0]
      period0 <- months0.diff.adjusted %>% mean()
      
      date_window <- dates0[n0 - window]
      
      if (period0 == 0) {
        
        start_date_observed <- year(dates0[1])
        end_date_observed <- year(dates0[n0])
        start_date_forecasted <- end_date_observed + 1
        start_date_plotting <- year(date_window)
        freq0 <- 1
        
      } else if (period0 == 3) {
        
        start_date_observed <- c(year(dates0[1]),
                                 quarter(dates0[1]))
        end_date_observed <- c(year(dates0[n0]),
                               quarter(dates0[n0]))
        start_date_forecasted <- c(end_date_observed[1], 
                                   end_date_observed[2]+1)
        start_date_plotting <- c(year(date_window),
                                 quarter(date_window))
        freq0 <- 4
        
      } else if (period0 == 1) {
        
        start_date_observed <- c(year(dates0[1]),
                                 month(dates0[1]))
        end_date_observed <- c(year(dates0[n0]),
                               month(dates0[n0]))
        start_date_forecasted <- c(end_date_observed[1], 
                                   end_date_observed[2]+1)
        start_date_plotting <- c(year(date_window),
                                 month(date_window))
        freq0 <- 12
        
      } else {
        
        stop("Error: Series must be monthly, quarterly, or annual")
        
      }
      
      return(list(start_date_observed,start_date_forecasted, freq0, start_date_plotting))
      
    }
    
    results.calculate_dates <- calculate_dates(tibble = tibble0, window = window)
    
    results.start_date_observed <- results.calculate_dates[[1]]
    results.start_date_forecasted <- results.calculate_dates[[2]]
    results.freq <- results.calculate_dates[[3]]
    results.start_date_plotting <- results.calculate_dates[[4]]
    
    ts0 <- ts(tibble0$value,
              start = results.start_date_observed, 
              frequency = results.freq)
    h0 <- as.integer(h)
    nsim0 <- as.integer(nsim)
    conf0 = as.numeric(conf)
    
    fcast_mean <- function(ts, h, nsim) {
      
      matrix.fcast_mean <- matrix(0:0, nrow=1,ncol=h)
      fitted.fcast_mean <- c()
      for (i in 1:(length(ts))) {
        fitted.fcast_mean <- c(fitted.fcast_mean, mean(as.numeric(ts)))
      }
      
      for (i in 1:nsim) {
        
        initial.fcast_mean <- rnorm(1, mean = mean(as.numeric(ts)), sd = sd(as.numeric(ts)))
        sim.fcast_mean <- c(initial.fcast_mean)
        total.fcast_mean <- c(as.numeric(ts), initial.fcast_mean)
        
        for (j in 1:(h-1)) {
          
          additional.fcast_mean <- rnorm(1, 
                                         mean = mean(total.fcast_mean),
                                         sd = sd(total.fcast_mean))
          sim.fcast_mean <- c(sim.fcast_mean, additional.fcast_mean)
          total.fcast_mean <- c(total.fcast_mean, additional.fcast_mean)
          
        }
        
        matrix.fcast_mean <- rbind(matrix.fcast_mean, sim.fcast_mean)
        
      }
      
      row.names(matrix.fcast_mean) <- c(0:nsim)
      
      return(list(matrix.fcast_mean, fitted.fcast_mean))
      
    }
    
    fcast_arima <- function(ts, h, nsim) {
      
      matrix.fcast_arima <- matrix(0:0, nrow=1,ncol=h)
      fit.fcast_arima <- auto.arima(ts)
      fitted.fcast_arima <- as.numeric(fit.fcast_arima$fitted)
      
      for (i in 1:nsim) {
        
        sim.fcast_arima <- simulate(fit.fcast_arima, nsim = h)
        matrix.fcast_arima <- rbind(matrix.fcast_arima, sim.fcast_arima)
        
      }
      
      row.names(matrix.fcast_arima) <- c(0:nsim)
      
      return(list(matrix.fcast_arima, fitted.fcast_arima))
      
    }
    
    fcast_naive <- function(ts, h, nsim) {
      
      matrix.fcast_naive <- matrix(0:0, nrow=1,ncol=h)
      fit.fcast_naive <- Arima(ts, order = c(1,0,0), seasonal = c(0,0,0))
      fitted.fcast_naive <- as.numeric(fit.fcast_naive$fitted)
      
      for (i in 1:nsim) {
        
        sim.fcast_naive <- simulate(fit.fcast_naive, nsim = h)
        matrix.fcast_naive <- rbind(matrix.fcast_naive, sim.fcast_naive)
        
      }
      
      row.names(matrix.fcast_naive) <- c(0:nsim)
      
      return(list(matrix.fcast_naive, fitted.fcast_naive))
      
    }
    
    fcast_snaive <- function(ts, h, nsim) {
      
      matrix.fcast_snaive <- matrix(0:0, nrow=1,ncol=h)
      fit.fcast_snaive <- Arima(ts, order = c(0,0,0), seasonal = c(1,0,0))
      fitted.fcast_snaive <- as.numeric( fit.fcast_snaive$fitted )
      
      for (i in 1:nsim) {
        
        sim.fcast_snaive <- simulate(fit.fcast_snaive, nsim = h)
        matrix.fcast_snaive <- rbind(matrix.fcast_snaive, sim.fcast_snaive)
        
      }
      
      row.names(matrix.fcast_snaive) <- c(0:nsim)
      
      return(list(matrix.fcast_snaive, fitted.fcast_snaive))
      
    }
    
    fcast_ets <- function(ts, h, nsim) {
      
      matrix.fcast_ets <- matrix(0:0, nrow=1,ncol=h)
      fit.fcast_ets <- ets(ts)
      fitted.fcast_ets <- as.numeric(fit.fcast_ets$fitted)
      
      for (i in 1:nsim) {
        
        sim.fcast_ets <- simulate(fit.fcast_ets, nsim = h)
        matrix.fcast_ets <- rbind(matrix.fcast_ets, sim.fcast_ets)
        
      }
      
      row.names(matrix.fcast_ets) <- c(0:nsim)
      
      return(list(matrix.fcast_ets, fitted.fcast_ets))
      
    }
    
    fcast_nnetar <- function(ts, h, nsim) {
      
      matrix.fcast_nnetar <- matrix(0:0, nrow=1,ncol=h)
      fit.fcast_nnetar <- nnetar(ts)
      fitted.fcast_nnetar <- as.numeric(fit.fcast_nnetar$fitted)
      
      for (i in 1:nsim) {
        
        sim.fcast_nnetar <- simulate(fit.fcast_nnetar, nsim = h)
        matrix.fcast_nnetar <- rbind(matrix.fcast_nnetar, sim.fcast_nnetar)
        
      }
      
      row.names(matrix.fcast_nnetar) <- c(0:nsim)
      
      return(list(matrix.fcast_nnetar, fitted.fcast_nnetar))
      
    }
    
    results.fcast_mean <- fcast_mean(ts0, h0, nsim0)
    results.fcast_arima <- fcast_arima(ts0, h0, nsim0)
    results.fcast_naive <- fcast_naive(ts0, h0, nsim0)
    results.fcast_snaive <- fcast_snaive(ts0, h0, nsim0)
    results.fcast_ets <- fcast_ets(ts0, h0, nsim0)
    results.fcast_nnetar <- fcast_nnetar(ts0, h0, nsim0)
    
    results.combined <- (1/6)*(results.fcast_mean[[1]] + results.fcast_arima[[1]] + results.fcast_naive[[1]] + results.fcast_snaive[[1]] + results.fcast_ets[[1]] + results.fcast_nnetar[[1]])
    results.combined_fitted <- (1/6)*(results.fcast_mean[[2]] + results.fcast_arima[[2]] + results.fcast_naive[[2]] + results.fcast_snaive[[2]] + results.fcast_ets[[2]] + results.fcast_nnetar[[2]])
    
    calculate_intervals <- function(matrix, h, nsim, conf) {
      
      lower <- c()
      middle <- c()
      upper <- c()
      
      lower_bound <- (1 - conf) / 2
      upper_bound <- 1 - (1 - conf) / 2
      
      for (i in 1:h) {
        
        lower <- c(lower, 
                   as.numeric(quantile(matrix[2:nsim,i], probs = lower_bound)))
        middle <- c(middle, 
                    mean(matrix[2:nsim,i]))
        upper <- c(upper, 
                   as.numeric(quantile(matrix[2:nsim,i], probs = upper_bound)))
        
      }
      
      return(list(lower, middle, upper))
      
    }
    
    results.intervals <- calculate_intervals(matrix = results.combined, 
                                             h = h0,
                                             nsim = nsim0,
                                             conf = conf0)
    
    results.lower <- ts(results.intervals[[1]],
                        frequency = freq0,
                        start = results.start_date_forecasted)
    results.middle <- ts(results.intervals[[2]],
                         frequency = freq0,
                         start = results.start_date_forecasted)
    results.upper <- ts(results.intervals[[3]],
                        frequency = freq0,
                        start = results.start_date_forecasted)
    
    results.fitted <- ts(results.combined_fitted,
                         freq = freq0,
                         start = results.start_date_observed)
    
    results.residuals <- results.fitted - ts0
    
    structure_fcast <- function(ts, lower, middle, upper, fitted, residuals) {
      
      output <- list(x = ts,
                     mean = middle, 
                     lower = lower, 
                     upper = upper,
                     level = (conf0*100),
                     fitted = fitted,
                     residuals = residuals)
      
      return(structure(output, class="forecast"))
      
    }
    
    results.structure_fcast <- structure_fcast(ts = ts0,
                                               lower = results.lower,
                                               middle = results.middle,
                                               upper = results.upper,
                                               fitted = results.fitted,
                                               residuals = results.residuals
    )
    
    return(results.structure_fcast)
    
  }
  
  if (freq %in% c("m","q","a") || is.null(freq) && h == round(h) && h > 0 && nsim == round(nsim) && window == round(window) && nsim >= 200  && between(conf,0,1)) {
    compute(fred_api_key = fred_api_key,
            fred_series_id = fred_series_id,
            freq = freq,
            h = h,
            nsim = nsim,
            conf = conf,
            units = units,
            aggregation_method = aggregation_method,
            window = window)
  } else {
    stop("Error: invalid inputs \n 
         - freq must be an integer > 0 (the periodicity of the time series) \n
         - h must be an integer > 0 (the forecast horizon) \n
         - nsim must be an integer >= 200 (the number of simulations for bootsrapping) \n
         - conf must be a numeric between 0 and 1 (the confidence interval)")
  }
  
}
